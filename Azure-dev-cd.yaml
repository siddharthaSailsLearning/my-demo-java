
name: MyReleasePipeline

trigger: none 

resources:
  pipelines:
    - pipeline: CI-pipeline-GAR 
      source: CI-pipeline-GAR
      trigger: true 

pr: none

pool:
  vmImage: 'ubuntu-latest'

variables:
- group: cd-pipeline-vars
- name: IMAGE_TAG
  value: $[ resources['CI-pipeline-GAR'].runID ]


stages:
  - stage: DeployToGKE
    displayName: Deploy to GKE (us-central1-a)
    jobs:
      - job: Deploy
        displayName: Deploy image from GAR to GKE
        steps:

          - script: |
              echo "CI run id (image tag): $(IMAGE_TAG)"
              echo "Image: $(LOCATION)-docker.pkg.dev/$(PROJECT_ID)/$(REPOSITORY)/$(IMAGE_NAME):$(IMAGE_TAG)"
            displayName: 'Show calculated image information'

          - task: DownloadSecureFile@1
            name: DownloadGcpKey
            inputs:
              secureFile: '$(SERVICE_ACCOUNT_SECUREFILE)'

          - script: |
              set -e
              echo "Installing gcloud SDK and kubectl..."
              sudo apt-get update -y
              sudo apt-get install -y apt-transport-https ca-certificates gnupg curl lsb-release

              echo "Adding Google Cloud SDK apt repo..."
              echo "deb [signed-by=/usr/share/keyrings/cloud.google.gpg] http://packages.cloud.google.com/apt cloud-sdk main" | sudo tee /etc/apt/sources.list.d/google-cloud-sdk.list
              curl https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key --keyring /usr/share/keyrings/cloud.google.gpg add -
              sudo apt-get update -y
              sudo apt-get install -y google-cloud-sdk kubectl google-cloud-sdk-gke-gcloud-auth-plugin

              KEY_DIR="$(System.DefaultWorkingDirectory)/gcp"
              mkdir -p "$KEY_DIR"
              mv "$(DownloadGcpKey.secureFilePath)" "$KEY_DIR/$(SERVICE_ACCOUNT_SECUREFILE)"
              chmod 600 "$KEY_DIR/$(SERVICE_ACCOUNT_SECUREFILE)"

              export GOOGLE_APPLICATION_CREDENTIALS="$KEY_DIR/$(SERVICE_ACCOUNT_SECUREFILE)"
              echo "Activating service account..."
              gcloud auth activate-service-account --key-file="$GOOGLE_APPLICATION_CREDENTIALS"
              gcloud config set project $(PROJECT_ID)

              # If you used CI to push to GAR using gcloud auth configure-docker, the image is available in GAR now.
              # Optionally configure docker auth in case container builds/pulls are done on this agent:
              gcloud auth configure-docker $(LOCATION)-docker.pkg.dev --quiet
            displayName: 'Install gcloud & kubectl and activate service account'
            env:
              CLOUDSDK_AUTH_CREDENTIAL_FILE_OVERRIDE: '$(System.DefaultWorkingDirectory)/gcp/$(SERVICE_ACCOUNT_SECUREFILE)'

          - script: |
              set -e
              CLUSTER_NAME=$(CLUSTER_NAME)
              ZONE=$(ZONE)
              PROJECT=$(PROJECT_ID)

              # Check if cluster exists
              if gcloud container clusters describe "$CLUSTER_NAME" --zone "$ZONE" --project "$PROJECT" >/dev/null 2>&1; then
                echo "Cluster $CLUSTER_NAME already exists in zone $ZONE."

              else
                echo "Creating cluster $CLUSTER_NAME in zone $ZONE..."

                # Create a small cluster with node service account that can pull from GAR
                # Replace with your node count / machine type as needed
                gcloud container clusters create "$CLUSTER_NAME" \
                  --zone "$ZONE" \
                  --num-nodes 1 \
                  --machine-type=e2-medium \
                  --service-account="$SERVICE_ACC_DET"@"$PROJECT".iam.gserviceaccount.com \
                  --project "$PROJECT" \
                  --quiet

                echo "Cluster created."
              fi

              # Fetch kubeconfig credentials
              gcloud container clusters get-credentials "$CLUSTER_NAME" --zone "$ZONE" --project "$PROJECT"
            displayName: 'Create cluster if missing & get credentials'
            env:
              CLOUDSDK_AUTH_CREDENTIAL_FILE_OVERRIDE: '$(System.DefaultWorkingDirectory)/gcp/$(SERVICE_ACCOUNT_SECUREFILE)'

          - script: |
              echo "Verifying node service account permissions..."

              # (This is informational; the actual grant should be done via IAM at infra time.)
              echo "Make sure gke-node-sa@$PROJECT_ID.iam.gserviceaccount.com has roles/artifactregistry.reader"
            displayName: 'Verify node SA has access to GAR'

          - script: |
              set -e
              IMAGE_URI="$(LOCATION)-docker.pkg.dev/$(PROJECT_ID)/$(REPOSITORY)/$(IMAGE_NAME):$(IMAGE_TAG)"
              echo "Deploying image: $IMAGE_URI"

              # create a work copy of manifests
              mkdir -p $(System.DefaultWorkingDirectory)/k8s_work
              sed "s|PLACEHOLDER_IMAGE|$IMAGE_URI|g" k8s/deployment.yaml > $(System.DefaultWorkingDirectory)/k8s_work/deployment.yaml
              cp k8s/service.yaml $(System.DefaultWorkingDirectory)/k8s_work/service.yaml

              kubectl apply -f $(System.DefaultWorkingDirectory)/k8s_work/deployment.yaml
              kubectl apply -f $(System.DefaultWorkingDirectory)/k8s_work/service.yaml

              # optionally wait for rollout to complete
              kubectl rollout status deployment/sample-javaapp --timeout=180s

              echo "Deployment applied."
            displayName: 'Apply Kubernetes manifests (deploy image)'
            env:
              CLOUDSDK_AUTH_CREDENTIAL_FILE_OVERRIDE: '$(System.DefaultWorkingDirectory)/gcp/$(SERVICE_ACCOUNT_SECUREFILE)'

          - script: |
              echo "Cleaning up key files..."
              rm -f "$(System.DefaultWorkingDirectory)/gcp/$(SERVICE_ACCOUNT_SECUREFILE)"
            displayName: 'Cleanup key'
